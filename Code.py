# -*- coding: utf-8 -*-
"""DCproject.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sLeYY8wmJ9_BOyu81I6JphxGDXCWTA7s
"""

cimport numpy as np
import matplotlib.pyplot as plt
from skimage.transform import radon, iradon
import tensorflow as tf
from tensorflow.keras import layers, models
from sklearn.model_selection import train_test_split

# Function to create synthetic circle images
def create_circle_image(size=128):
    img = np.zeros((size, size), dtype=np.float32)
    rr, cc = np.ogrid[:size, :size]
    center = (size // 2, size // 2)
    radius = size // 4
    mask = (rr - center[0])**2 + (cc - center[1])**2 <= radius**2
    img[mask] = 1
    return img

# Generate a dataset of synthetic circle images
num_images = 1000
image_size = 128
images = np.array([create_circle_image(image_size) for _ in range(num_images)])

# Visualize a sample image
plt.imshow(images[0], cmap='gray')
plt.title('Sample Synthetic Image')
plt.show()

# Function to compute Radon transform (sinogram)
def compute_sinogram(image, theta=None):
    if theta is None:
        theta = np.linspace(0., 180., max(image.shape), endpoint=False)
    return radon(image, theta=theta, circle=True)

# Compute sinograms for the entire dataset
theta = np.linspace(0., 180., image_size, endpoint=False)
sinograms = np.array([compute_sinogram(img, theta=theta) for img in images])

# Display a sample sinogram
plt.imshow(sinograms[0], cmap='gray')
plt.title('Sample Sinogram')
plt.show()

# Reshape images and sinograms for input into the neural network
images = images[..., np.newaxis]  # Add channel dimension for CNN
sinograms = sinograms[..., np.newaxis]  # Add channel dimension for CNN

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(sinograms, images, test_size=0.2, random_state=42)

print(f"Training data shape: {X_train.shape}, {y_train.shape}")
print(f"Testing data shape: {X_test.shape}, {y_test.shape}")

# Define the neural network model (CNN-based)
def build_model(input_shape):
    model = models.Sequential()

    # Encoder: Convolutional layers
    model.add(layers.Conv2D(32, (3, 3), activation='relu', padding='same', input_shape=input_shape))
    model.add(layers.MaxPooling2D((2, 2)))
    model.add(layers.Conv2D(64, (3, 3), activation='relu', padding='same'))
    model.add(layers.MaxPooling2D((2, 2)))

    # Decoder: Transposed convolutional layers
    model.add(layers.Conv2DTranspose(64, (3, 3), activation='relu', padding='same'))
    model.add(layers.UpSampling2D((2, 2)))
    model.add(layers.Conv2DTranspose(32, (3, 3), activation='relu', padding='same'))
    model.add(layers.UpSampling2D((2, 2)))

    # Output layer: 1 channel (grayscale image)
    model.add(layers.Conv2D(1, (3, 3), activation='sigmoid', padding='same'))

    return model

# Build and compile the model
input_shape = X_train.shape[1:]  # Shape of sinograms
model = build_model(input_shape)
model.compile(optimizer='adam', loss='mse')

# Display the model architecture
model.summary()

# Train the model on the sinograms and original images
history = model.fit(X_train, y_train, epochs=20, batch_size=32, validation_data=(X_test, y_test))

# Plot the training loss and validation loss
plt.plot(history.history['loss'], label='Training Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.title('Model Loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()
plt.show()

# Evaluate the model on the test set
loss = model.evaluate(X_test, y_test)
print(f"Test Loss: {loss}")

# Reconstruct images from test sinograms
reconstructed_images = model.predict(X_test)

# Display original image, sinogram, and reconstructed image for a sample
idx = 0
plt.figure(figsize=(12, 4))

# Original image
plt.subplot(1, 3, 1)
plt.imshow(y_test[idx].squeeze(), cmap='gray')
plt.title('Original Image')

# Sinogram
plt.subplot(1, 3, 2)
plt.imshow(X_test[idx].squeeze(), cmap='gray')
plt.title('Sinogram')

# Reconstructed image
plt.subplot(1, 3, 3)
plt.imshow(reconstructed_images[idx].squeeze(), cmap='gray')
plt.title('Reconstructed Image')

plt.show()